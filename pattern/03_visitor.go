package pattern

import "fmt"

// Интерфейс элемента
type Shape interface {
	Accept(Visitor)
}

// Конкретные элементы
type Circle struct {
	Radius float64
}

func (c *Circle) Accept(v Visitor) {
	v.VisitCircle(c)
}

type Square struct {
	Side float64
}

func (s *Square) Accept(v Visitor) {
	v.VisitSquare(s)
}

type Triangle struct {
	Base   float64
	Height float64
}

func (t *Triangle) Accept(v Visitor) {
	v.VisitTriangle(t)
}

// Интерфейс посетителя
type Visitor interface {
	VisitCircle(*Circle)
	VisitSquare(*Square)
	VisitTriangle(*Triangle)
}

// Конкретный посетитель для вычисления площади
type AreaVisitor struct {
	TotalArea float64
}

func (av *AreaVisitor) VisitCircle(c *Circle) {
	av.TotalArea += 3.14159265359 * c.Radius * c.Radius
}

func (av *AreaVisitor) VisitSquare(s *Square) {
	av.TotalArea += s.Side * s.Side
}

func (av *AreaVisitor) VisitTriangle(t *Triangle) {
	av.TotalArea += 0.5 * t.Base * t.Height
}

func main() {
	// Создаем коллекцию геометрических фигур
	shapes := []Shape{
		&Circle{Radius: 5},
		&Square{Side: 4},
		&Triangle{Base: 3, Height: 6},
	}

	// Создаем посетителя для вычисления площади
	areaVisitor := &AreaVisitor{}

	// Применяем посетителя к каждой фигуре
	for _, shape := range shapes {
		shape.Accept(areaVisitor)
	}

	// Выводим общую площадь
	fmt.Printf("Общая площадь: %.2f\n", areaVisitor.TotalArea)
}

/*
Паттерн "Посетитель" полезен, когда у вас есть сложная структура объектов, и вам нужно выполнять различные операции с этими объектами без изменения их классов.
Вот некоторые ситуации, когда паттерн "Посетитель" может быть применен:

Обработка разнородных объектов: Когда вам нужно обрабатывать объекты разных классов, но с общим интерфейсом, без добавления методов в эти классы.

Добавление новых операций без изменения классов: Если вы хотите добавить новые операции или алгоритмы для группы классов, но не хотите изменять сами классы.

Разделение операций на отдельные классы: Когда вы хотите разделить операции на несколько отдельных классов (посетителей), чтобы сделать код более модульным и поддерживаемым.



Плюсы паттерна "Посетитель":

Отделение алгоритмов от структуры объектов: Паттерн позволяет разместить алгоритмы в отдельных посетителях, отделяя их от структуры объектов.

Добавление новых операций легко: Вы можете добавлять новые операции, создавая новые посетителей, без изменения существующих классов объектов.

Обход сложных структур данных: Паттерн "Посетитель" облегчает обход и выполнение операций над сложными структурами данных, такими как деревья или графы.

Поддержка Open/Closed Principle: Паттерн "Посетитель" способствует соблюдению принципа открытости/закрытости, так как новые операции добавляются через создание новых посетителей,
а не изменением существующих классов.


Минусы паттерна "Посетитель":

Усложнение кода: Паттерн "Посетитель" может увеличить сложность кода из-за необходимости создания отдельных посетителей для каждой новой операции.

Нарушение инкапсуляции: Посетитель может обращаться к внутренним данным объектов, что нарушает инкапсуляцию и может сделать код менее надежным.



Реальные примеры использования на практике:

Анализаторы и компиляторы: В компиляторах и анализаторах языков программирования паттерн "Посетитель" используется для обхода и анализа абстрактного синтаксического дерева (AST).

Графические библиотеки: Графические библиотеки могут использовать паттерн "Посетитель" для реализации рендеринга и обработки графических объектов.

Базы данных: При работе с базами данных можно использовать паттерн "Посетитель" для выполнения различных запросов к данным.

Обработка XML или JSON: При обработке структурированных данных в форматах XML или JSON паттерн "Посетитель" может помочь различными операциями, такими как валидация, фильтрация или трансформация данных.

Моделирование и симуляция: В инженерных приложениях и симуляциях можно использовать паттерн "Посетитель" для моделирования взаимодействия различных компонентов системы.
*/
