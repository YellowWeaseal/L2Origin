package pattern

import (
	"fmt"
)

// Интерфейс, представляющий состояние
type State interface {
	Handle() string
}

// Конкретное состояние 1
type State1 struct{}

func (s *State1) Handle() string {
	return "Состояние 1"
}

// Конкретное состояние 2
type State2 struct{}

func (s *State2) Handle() string {
	return "Состояние 2"
}

// Контекст, в котором может меняться состояние
type Context struct {
	state State
}

func NewContext() *Context {
	return &Context{
		state: &State1{},
	}
}

// Метод для изменения состояния
func (c *Context) ChangeState(newState State) {
	c.state = newState
}

// Метод для выполнения операции, зависящей от текущего состояния
func (c *Context) DoOperation() string {
	return c.state.Handle()
}

func main() {
	context := NewContext()

	// Выполняем операцию в начальном состоянии
	fmt.Println(context.DoOperation())

	// Меняем состояние
	context.ChangeState(&State2{})

	// Выполняем операцию в новом состоянии
	fmt.Println(context.DoOperation())
}

/*

Паттерн "Состояние" (State) применяется в тех случаях, когда объект может находиться в различных состояниях, и его поведение зависит от текущего состояния:

Применимость:

Когда объект имеет множество состояний, и его поведение меняется в зависимости от текущего состояния.
Когда код объекта становится сложным из-за множества условных операторов, которые зависят от состояния.
Когда вы хотите сделать объекты более гибкими и расширяемыми, позволяя добавлять новые состояния и соответствующие им поведения без изменения существующего кода.


Плюсы паттерна "Состояние":

Разделение ответственности: Паттерн позволяет разделить поведение объекта на отдельные состояния, что делает код более чистым и поддерживаемым.
Уменьшение условных операторов: Паттерн уменьшает количество условных операторов в коде, что делает его более читаемым и понятным.
Гибкость и расширяемость: Добавление новых состояний и изменение поведения объекта становится более гибкими и не требует изменения существующего кода.
Изолированные состояния: Каждое состояние инкапсулируется в отдельном классе, что позволяет избежать конфликтов между состояниями.


Минусы паттерна "Состояние":

Увеличение числа классов: Паттерн может привести к увеличению числа классов в системе, что может усложнить ее структуру.
Усложнение отладки: Поскольку поведение объекта зависит от его текущего состояния, отладка может быть сложной при сложных переходах между состояниями.
Не всегда оправдан: Паттерн "Состояние" не всегда оправдан, и его использование должно быть обоснованным, так как он может увеличить сложность кода.


Примеры использования на практике:

Контекстные меню в графических интерфейсах: Объекты контекстных меню могут иметь различное поведение в зависимости от текущего состояния приложения (например, активно ли какое-то действие).
Управление состоянием заказа в электронной коммерции: Заказ может находиться в разных состояниях (например, ожидание оплаты, обработка, доставка), и его поведение и доступные операции зависят от текущего состояния заказа.
Управление студентами в учебных системах: Студент может находиться в различных состояниях (например, зарегистрирован, находится на лекции, сдает экзамен), и доступные функции для студента могут меняться в зависимости от его текущего состояния.
Управление состоянием сетевых соединений: Сетевые соединения могут находиться в различных состояниях (например, установлено, разорвано, ожидает подключения), и поведение приложения зависит от текущего состояния соединения.
*/
