package pattern

import "fmt"

// Интерфейс Product определяет методы, которые должны быть реализованы всеми продуктами.
type Thing interface {
	GetName() string
}

// ConcreteProductA - конкретный продукт A
type ConcreteProductA struct{}

func (p *ConcreteProductA) GetName() string {
	return "Product A"
}

// ConcreteProductB - конкретный продукт B
type ConcreteProductB struct{}

func (p *ConcreteProductB) GetName() string {
	return "Product B"
}

// Factory - интерфейс фабрики
type Factory interface {
	CreateProduct() Product
}

// ConcreteFactoryA - конкретная фабрика A
type ConcreteFactoryA struct{}

func (f *ConcreteFactoryA) CreateProduct() Thing {
	return &ConcreteProductA{}
}

// ConcreteFactoryB - конкретная фабрика B
type ConcreteFactoryB struct{}

func (f *ConcreteFactoryB) CreateProduct() Thing {
	return &ConcreteProductB{}
}

func main() {
	// Создаем фабрику A и производим продукт A
	factoryA := &ConcreteFactoryA{}
	productA := factoryA.CreateProduct()
	fmt.Printf("Product Name: %s\n", productA.GetName())

	// Создаем фабрику B и производим продукт B
	factoryB := &ConcreteFactoryB{}
	productB := factoryB.CreateProduct()
	fmt.Printf("Product Name: %s\n", productB.GetName())
}

/*
Применимость паттерна Фабричного метода (Factory Method):

Паттерн Фабричного метода применяется в ситуациях, когда необходимо создавать объекты определенного типа, но конкретный класс объекта, который нужно создать,
зависит от контекста или условий во время выполнения. Примеры ситуаций, когда можно использовать этот паттерн:

Создание продуктов в фреймворках и библиотеках: Фреймворки и библиотеки часто предоставляют абстрактные классы или интерфейсы,
а конкретную реализацию объектов нужно предоставить разработчикам приложений. Фабричный метод позволяет разработчикам выбирать и создавать конкретные объекты.

Различные типы коннекторов или драйверов: Например, в базах данных существует несколько типов драйверов (MySQL, PostgreSQL и т. д.).
Фабричный метод может использоваться для создания соответствующего драйвера в зависимости от типа базы данных.

Создание игровых персонажей или объектов в играх: В компьютерных играх могут быть разные типы персонажей, монстров или объектов.
Фабричный метод помогает создавать эти объекты в соответствии с правилами игры.

Работа с разными форматами файлов: В приложениях для обработки файлов (например, графических редакторах) можно использовать фабричный метод для создания объектов,
способных работать с разными форматами файлов (JPEG, PNG и другие).



Плюсы паттерна Фабричного метода:

Расширяемость: Позволяет добавлять новые типы продуктов или конкретных фабрик, не изменяя существующий код.

Отделение клиентского кода от конкретных классов продуктов: Клиентский код работает с абстрактными типами (интерфейсами), а не с конкретными классами, что упрощает поддержку и расширение приложения.

Гарантированное соответствие интерфейсам: Подклассы фабрик гарантированно реализуют интерфейс создаваемых объектов.



Минусы паттерна Фабричного метода:

Усложнение структуры кода: Для каждого типа продукта нужно создавать свой подкласс фабрики, что может усложнить структуру кода.

Дублирование кода в подклассах фабрик: Подклассы фабрик могут иметь общий код для создания продуктов, что может привести к дублированию кода.

Создание большого числа классов: В больших системах может возникнуть множество классов, что может быть сложно управлять.



Реальные примеры использования на практике:

Java Collections Framework: Фреймворк коллекций в Java использует фабричные методы, такие как ArrayList и HashMap, для создания экземпляров коллекций.

Фреймворк Spring: В Spring Framework фабричные методы используются для создания бинов и компонентов в контейнере IoC (Inversion of Control).

Browsers: В веб-браузерах есть фабричные методы для создания объектов, таких как разные виды окон и вкладок.

Графические редакторы: Графические редакторы могут использовать фабричные методы для создания различных инструментов рисования (кисть, ластик и т. д.).

Игры: В играх фабричные методы могут использоваться для создания игровых персонажей, оружия и других игровых объектов.
*/
