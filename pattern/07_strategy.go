package pattern

import (
	"fmt"
	"sort"
)

// Создаем интерфейс для наших стратегий сортировки
type SortStrategy interface {
	Sort([]int) []int
}

// Реализуем конкретную стратегию сортировки (например, сортировку пузырьком)
type BubbleSortStrategy struct{}

func (b BubbleSortStrategy) Sort(data []int) []int {
	n := len(data)
	swapped := true
	for swapped {
		swapped = false
		for i := 1; i < n; i++ {
			if data[i-1] > data[i] {
				data[i-1], data[i] = data[i], data[i-1]
				swapped = true
			}
		}
	}
	return data
}

// Реализуем другую стратегию сортировки (например, сортировку с использованием стандартной библиотеки)
type StandardSortStrategy struct{}

func (s StandardSortStrategy) Sort(data []int) []int {
	sort.Ints(data)
	return data
}

// Клиентский код, который использует стратегию сортировки
func main() {
	data := []int{5, 2, 9, 3, 6}

	// Выбираем стратегию сортировки (можно заменить на другую стратегию)
	strategy := BubbleSortStrategy{}
	//strategy := StandardSortStrategy{}

	sortedData := strategy.Sort(data)
	fmt.Println("Отсортированный массив:", sortedData)
}

/*
Паттерн "Стратегия" (Strategy) применяется в тех случаях, когда необходимо определить семейство алгоритмов,
инкапсулировать каждый из них и предоставить клиенту возможность выбора необходимого алгоритма во время выполнения программы:

Применимость:

Когда у вас есть несколько схожих классов, выполняющих одну и ту же операцию, но с различными алгоритмами, и вы хотите сделать эти алгоритмы взаимозаменяемыми.
Когда у вас есть множество условных операторов, в которых выбирается один из нескольких алгоритмов, и вы хотите избежать "раздутия" кода.
Когда вам нужно иметь возможность легко добавлять новые алгоритмы без изменения существующего кода.
Когда вам нужно скрыть детали реализации алгоритмов от клиентов.


Плюсы паттерна "Стратегия":

Инкапсуляция алгоритмов: Каждая стратегия инкапсулируется в собственном классе, что делает код более структурированным и обеспечивает высокую когерентность.
Взаимозаменяемость: Стратегии могут быть легко заменены другими без изменения клиентского кода.
Уменьшение условных операторов: Паттерн позволяет избежать большого количества условных операторов, которые выбирают алгоритм.
Расширяемость: Добавление новых стратегий не требует изменения существующего кода, что делает систему более расширяемой.
Улучшение тестирования: Тестирование отдельных стратегий становится более простым, так как каждая стратегия имеет свой собственный интерфейс.


Минусы паттерна "Стратегия":

Увеличение числа классов: Паттерн может привести к увеличению количества классов в системе, что может усложнить ее структуру.
Увеличение сложности конфигурации: Если необходимо множество стратегий с различными параметрами, конфигурирование может стать сложным.
Увеличение сложности понимания: Клиенты могут столкнуться с дополнительной сложностью в выборе подходящей стратегии.
Примеры использования на практике:

Графические редакторы: В графических редакторах можно использовать паттерн "Стратегия" для выбора различных режимов рисования (карандаш, кисть, ластик) с возможностью их легкой замены и добавления новых инструментов.
Системы сортировки: Как показано в предыдущем примере, паттерн "Стратегия" может использоваться для выбора различных алгоритмов сортировки (сортировка пузырьком, быстрая сортировка и т. д.) в зависимости от конкретных требований.
Алгоритмы сжатия данных: В системах обработки данных можно применять стратегии сжатия данных (например, gzip, zlib) с возможностью переключения между ними в зависимости от контекста.
Торговые стратегии в финансовых приложениях: Финансовые приложения могут использовать паттерн "Стратегия" для реализации различных торговых стратегий и их динамического выбора.
*/
